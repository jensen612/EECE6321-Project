//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// Wed Mar 22 2017 21:07:50
//
//      Input file      : 
//      Component name  : valu_controlunit
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------
// Some signals like x, xhdl0 needs to be modified
// always should be always@(posedge clk)

module valu_controlunit(clk, valu_go, valuop, vwidth, source_sel, carry_sel, mult_source_sel, mult_dest_sel, reg_input_sel, load_lsr, load_other, out_valid);
   input            clk;
   input            valu_go;
   input [3:0]      valuop;
   input [1:0]      vwidth;
   output [1:0]     source_sel;
   output [1:0]     carry_sel;
   output [1:0]     mult_source_sel;
   reg [1:0]        mult_source_sel;
   output [1:0]     mult_dest_sel;
   reg [1:0]        mult_dest_sel;
   output           reg_input_sel;
   reg              reg_input_sel;
   output           load_lsr;
   reg              load_lsr;
   output           load_other;
   reg              load_other;
   output           out_valid;
   reg              out_valid;
   
   parameter [2:0]  statetype_waiting = 0,
                    statetype_vlsr = 1,
                    statetype_vlsr64 = 2,
                    statetype_vother = 3,
                    statetype_vother64 = 4,
                    statetype_vmult8 = 5,
                    statetype_vmult16 = 6;
   reg [2:0]        state;
   reg [2:0]        nextstate;
   
   reg [0:0]        counter;
   reg              inc;
   reg              reset;
   
   
   always
   begin: xhdl0
      reg [0:0]        x;
      @(posedge clk);
      if (reset == 1'b1)
         counter <= {2{1'b0}};
      else
         if (inc == 1'b1)
         begin
            x = counter;
            counter <= counter + 1;
         end
   end
   
   
   always
   begin
      @(posedge clk);
      state <= nextstate;
   end
   
   
   always @(state or valu_go or valuop or vwidth or counter)
   begin: xhdl1
      reg [3:0]        lsr_result;
      out_valid <= 1'b0;
      
      reset <= 1'b0;
      inc <= 1'b0;
      
      load_lsr <= 1'b0;
      load_other <= 1'b0;
      
      mult_source_sel <= 2'b00;
      mult_dest_sel <= 2'b00;
      reg_input_sel <= 1'b0;
      
      case (state)
         statetype_waiting :
            begin
               out_valid <= 1'b1;
               reset <= 1'b1;
               nextstate <= statetype_waiting;
               
               if (valu_go == 1'b1)
                  case (valuop)
                     4'b1110 :
                        nextstate <= statetype_vlsr;
                     
                     4'b1011 :
                        if (vwidth[0] == 1'b0)
                           nextstate <= statetype_vmult8;
                        else
                           nextstate <= statetype_vmult16;
                     
                     default :
                        nextstate <= statetype_vother;
                  endcase
               else
                  nextstate <= statetype_waiting;
            end
         
         statetype_vother :
            begin
               inc <= 1'b1;
               load_other <= 1'b1;
               
               if (counter == 3)
               begin
                  if (vwidth == 2'b11)
                     nextstate <= statetype_vother64;
                  else
                     nextstate <= statetype_waiting;
               end
               else
                  nextstate <= statetype_vother;
            end
         
         statetype_vother64 :
            begin
               inc <= 1'b1;
               load_other <= 1'b1;
               
               if (counter == 3)
                  nextstate <= statetype_waiting;
               else
                  nextstate <= statetype_vother64;
            end
         
         statetype_vlsr :
            begin
               inc <= 1'b1;
               load_lsr <= 1'b1;
               
               if (counter == 3)
               begin
                  if (vwidth == 2'b11)
                     nextstate <= statetype_vlsr64;
                  else
                     nextstate <= statetype_waiting;
               end
               else
                  nextstate <= statetype_vlsr;
            end
         
         statetype_vlsr64 :
            begin
               inc <= 1'b1;
               load_lsr <= 1'b1;
               
               if (counter == 3)
                  nextstate <= statetype_waiting;
               else
                  nextstate <= statetype_vlsr64;
            end
         
         statetype_vmult8 :
            begin
               inc <= 1'b1;
               load_other <= 1'b1;
               
               reg_input_sel <= 1'b1;
               
               case (counter)
                  2'b00 :
                     begin
                        mult_source_sel <= 2'b00;
                        mult_dest_sel <= 2'b00;
                        nextstate <= statetype_vmult8;
                     end
                  2'b01 :
                     begin
                        mult_source_sel <= 2'b00;
                        mult_dest_sel <= 2'b01;
                        nextstate <= statetype_vmult8;
                     end
                  2'b10 :
                     begin
                        mult_source_sel <= 2'b01;
                        mult_dest_sel <= 2'b00;
                        nextstate <= statetype_vmult8;
                     end
                  2'b11 :
                     begin
                        mult_source_sel <= 2'b01;
                        mult_dest_sel <= 2'b01;
                        nextstate <= statetype_waiting;
                     end
                  default :
                     nextstate <= statetype_waiting;
               endcase
            end
         
         statetype_vmult16 :
            begin
               inc <= 1'b1;
               load_other <= 1'b1;
               
               mult_source_sel <= 2'b10;
               mult_dest_sel <= counter;
               reg_input_sel <= 1'b1;
               
               if (counter == 3)
                  nextstate <= statetype_waiting;
               else
                  nextstate <= statetype_vmult16;
            end
      endcase
   end
   
   assign source_sel = (((counter == 0 & valuop != 4'b1110) | (counter == 3 & valuop == 4'b1110))) ? 2'b00 : 
                       (((counter == 1 & valuop != 4'b1110) | (counter == 2 & valuop == 4'b1110))) ? 2'b01 : 
                       (((counter == 2 & valuop != 4'b1110) | (counter == 1 & valuop == 4'b1110))) ? 2'b10 : 
                       2'b11;
   
   assign carry_sel = ((vwidth == 2'b11 & counter == 0)) ? 2'b00 : 
                      ((vwidth[1] == 1'b1 & counter != 0)) ? 2'b01 : 
                      ((vwidth == 2'b01 & (counter == 1 | counter == 3))) ? 2'b01 : 
                      2'b10;
   
endmodule

