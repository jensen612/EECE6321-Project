//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// Wed Mar 22 2017 21:08:43
//
//      Input file      : 
//      Component name  : shuffle
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


module shuffle(clk, shuffle_go, shuffle_valid, data_in_v, data_in_w, vn, ssss, vwidth, shuffle_out_sel, data_out);
   input                        clk;
   input                        shuffle_go;
   output                       shuffle_valid;
   reg                          shuffle_valid;
   input                        data_in_v;
   input                        data_in_w;
   input [7:0]                  vn;
   input [3:0]                  ssss;
   input [1:0]                  vwidth;
   input [1:0]                  shuffle_out_sel;
   output                       data_out;
   
   parameter                    unit_width = max_shuffle_width/4;
   
   wire [32*k-1:0]              v;
   wire [32*k-1:0]              w;
   wire [32*k-1:0]              shuffle_output;
   wire [32*k-1:0]              output_xhdl1;
   wire [max_shuffle_width-1:0] input_xhdl0;
   reg [max_shuffle_width-1:0]  reg_xhdl2;
   wire [max_shuffle_width-1:0] perm00;
   wire [max_shuffle_width-1:0] perm01;
   wire [max_shuffle_width-1:0] perm10;
   wire [max_shuffle_width-1:0] permutation;
   wire [max_shuffle_width-1:0] perm00_rev;
   wire [max_shuffle_width-1:0] perm01_rev;
   wire [max_shuffle_width-1:0] perm10_rev;
   wire [max_shuffle_width-1:0] permutation_rev;
   
   wire [unit_width-1:0]        reg_input;
   
   reg                          shift;
   wire                         source;
   wire [1:0]                   sel;
   
   parameter [1:0]              statetype_waiting = 0,
                                statetype_shuffle = 1;
   reg [1:0]                    state;
   reg [1:0]                    nextstate;
   
   reg [1:0]                    counter;
   reg                          inc;
   reg                          reset;
   
   generate
      begin : xhdl3
         genvar                       i;
         for (i = 0; i <= k - 1; i = i + 1)
         begin : v_gen
            assign v[(i + 1) * 32 - 1:i * 32] = data_in_v[i];
         end
      end
   endgenerate
   
   generate
      if (use_shuffle)
      begin : shuffle_gen
         begin : xhdl4
            genvar                       i;
            for (i = 0; i <= k - 1; i = i + 1)
            begin : w_gen
               assign w[(i + 1) * 32 - 1:i * 32] = data_in_w[i];
            end
         end
         
         
         always
         begin
            @(posedge clk);
            state <= nextstate;
         end
         
         
         always @(state or counter or shuffle_go)
         begin
            inc <= 1'b0;
            reset <= 1'b0;
            shift <= 1'b0;
            shuffle_valid <= 1'b0;
            
            case (state)
               statetype_waiting :
                  begin
                     shuffle_valid <= 1'b1;
                     reset <= 1'b1;
                     
                     if (shuffle_go == 1'b1)
                        nextstate <= statetype_shuffle;
                     else
                        nextstate <= statetype_waiting;
                  end
               
               statetype_shuffle :
                  begin
                     shift <= 1'b1;
                     inc <= 1'b1;
                     
                     if (counter == 2'b11)
                        nextstate <= statetype_waiting;
                     else
                        nextstate <= statetype_shuffle;
                  end
            endcase
         end
         
         
         always
         begin
            @(posedge clk);
            if (reset == 1'b1)
               counter <= {2{1'b0}};
            else
               if (inc == 1'b1)
                  counter <= counter + 1'b1;
               else
                  counter <= counter;
         end
         
         
         always
         begin
            @(posedge clk);
            if (shift == 1'b1)
            begin
               reg_xhdl2[max_shuffle_width - unit_width - 1:0] <= reg_xhdl2[max_shuffle_width - 1:unit_width];
               reg_xhdl2[max_shuffle_width - 1:max_shuffle_width - unit_width] <= reg_input;
            end
            else
               reg_xhdl2 <= reg_xhdl2;
         end
         
         assign reg_input = ((sel == 2'b00)) ? permutation[1 * unit_width - 1:0 * unit_width] : 
                            ((sel == 2'b01)) ? permutation[2 * unit_width - 1:1 * unit_width] : 
                            ((sel == 2'b10)) ? permutation[3 * unit_width - 1:2 * unit_width] : 
                            permutation[4 * unit_width - 1:3 * unit_width];
         
         assign sel = ((counter == 2'b11)) ? vn[7:6] : 
                      ((counter == 2'b10)) ? vn[5:4] : 
                      ((counter == 2'b01)) ? vn[3:2] : 
                      vn[1:0];
         
         assign source = ((counter == 2'b11)) ? ssss[3] : 
                         ((counter == 2'b10)) ? ssss[2] : 
                         ((counter == 2'b01)) ? ssss[1] : 
                         ssss[0];
         
         assign input_xhdl0 = (source == 1'b0) ? v[max_shuffle_width - 1:0] : 
                              w[max_shuffle_width - 1:0];
         
         begin : xhdl8
            genvar                       i;
            for (i = 0; i <= 3; i = i + 1)
            begin : permutation_gen
               
               begin : xhdl5
                  genvar                       j;
                  for (j = 0; j <= 1; j = j + 1)
                  begin : perm_gen_10
                     assign perm10[(i * 2 + j + 1) * unit_width/2 - 1:(i * 2 + j) * unit_width/2] = input_xhdl0[(j * 4 + i + 1) * unit_width/2 - 1:(j * 4 + i) * unit_width/2];
                     
                     assign perm10_rev[(j * 4 + i + 1) * unit_width/2 - 1:(j * 4 + i) * unit_width/2] = reg_xhdl2[(i * 2 + j + 1) * unit_width/2 - 1:(i * 2 + j) * unit_width/2];
                  end
               end
               
               begin : xhdl6
                  genvar                       j;
                  for (j = 0; j <= 3; j = j + 1)
                  begin : perm_gen_01
                     assign perm01[(i * 4 + j + 1) * unit_width/4 - 1:(i * 4 + j) * unit_width/4] = input_xhdl0[(j * 4 + i + 1) * unit_width/4 - 1:(j * 4 + i) * unit_width/4];
                     
                     assign perm01_rev[(j * 4 + i + 1) * unit_width/4 - 1:(j * 4 + i) * unit_width/4] = reg_xhdl2[(i * 4 + j + 1) * unit_width/4 - 1:(i * 4 + j) * unit_width/4];
                  end
               end
               
               begin : xhdl7
                  genvar                       j;
                  for (j = 0; j <= 7; j = j + 1)
                  begin : perm_gen_00
                     assign perm00[(i * 8 + j + 1) * unit_width/8 - 1:(i * 8 + j) * unit_width/8] = input_xhdl0[(j * 4 + i + 1) * unit_width/8 - 1:(j * 4 + i) * unit_width/8];
                     
                     assign perm00_rev[(j * 4 + i + 1) * unit_width/8 - 1:(j * 4 + i) * unit_width/8] = reg_xhdl2[(i * 8 + j + 1) * unit_width/8 - 1:(i * 8 + j) * unit_width/8];
                  end
               end
            end
         end
         
         assign permutation = ((vwidth == 2'b11)) ? input_xhdl0 : 
                              ((vwidth == 2'b10)) ? perm10 : 
                              ((vwidth == 2'b01)) ? perm01 : 
                              perm00;
         
         assign permutation_rev = ((vwidth == 2'b11)) ? reg_xhdl2 : 
                                  ((vwidth == 2'b10)) ? perm10_rev : 
                                  ((vwidth == 2'b01)) ? perm01_rev : 
                                  perm00_rev;
         
         assign shuffle_output[max_shuffle_width - 1:0] = permutation_rev[max_shuffle_width - 1:0];
         
         if (k * 32 > max_shuffle_width)
         begin : greater_gen
            assign shuffle_output[k * 32 - 1:max_shuffle_width] = v[k * 32 - 1:max_shuffle_width];
         end
      end
   endgenerate
   
   generate
      if (((~use_shuffle)) & ((~use_vectorshift)))
      begin : not_shuffle_not_shift_gen
         assign output_xhdl1 = v;
      end
   endgenerate
   
   generate
      if ((use_shuffle) & ((~use_vectorshift)))
      begin : shuffle_not_shift_gen
         assign output_xhdl1 = (shuffle_out_sel[0] == 1'b0) ? shuffle_output : 
                               v;
      end
   endgenerate
   
   generate
      if (((~use_shuffle)) & (use_vectorshift))
      begin : not_shuffle_shift_gen
         assign output_xhdl1 = (shuffle_out_sel == 2'b10) ? {v[vectorshift_width - 1:0], v[32 * k - 1:vectorshift_width]} : 
                               (shuffle_out_sel == 2'b11) ? {v[32 * k - vectorshift_width - 1:0], v[32 * k - 1:32 * k - vectorshift_width]} : 
                               v;
      end
   endgenerate
   
   generate
      if ((use_shuffle) & (use_vectorshift))
      begin : shuffle_shift_gen
         assign output_xhdl1 = (shuffle_out_sel == 2'b00) ? shuffle_output : 
                               (shuffle_out_sel == 2'b01) ? v : 
                               (shuffle_out_sel == 2'b10) ? {v[vectorshift_width - 1:0], v[32 * k - 1:vectorshift_width]} : 
                               {v[32 * k - vectorshift_width - 1:0], v[32 * k - 1:32 * k - vectorshift_width]};
      end
   endgenerate
   
   generate
      begin : xhdl9
         genvar                       i;
         for (i = 0; i <= k - 1; i = i + 1)
         begin : out_gen
            assign data_out[i] = output_xhdl1[(i + 1) * 32 - 1:i * 32];
         end
      end
   endgenerate
   
endmodule
