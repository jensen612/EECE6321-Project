//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// Thu Mar 23 2017 17:06:36
//
//      Input file      : 
//      Component name  : vector_controlunit
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


module vector_controlunit(clk, ir, load_r, cc9, c10, c11, c12, cc13, valu_go, shuffle_go, out_valid, shuffle_valid, ir_ready, s_ready, s_fetched, v_ready, v_fetched, v_done);
   input            clk;
   
   input [31:0]     ir;
   
   output           load_r;
   reg              load_r;
   output [1:0]     cc9;
   reg [1:0]        cc9;
   output           c10;
   reg              c10;
   output           c11;
   reg              c11;
   output           c12;
   reg              c12;
   output [1:0]     cc13;
   reg [1:0]        cc13;
   output           valu_go;
   reg              valu_go;
   output           shuffle_go;
   reg              shuffle_go;
   
   input            out_valid;
   input            shuffle_valid;
   
   input            ir_ready;
   input            s_ready;
   input            s_fetched;
   
   output           v_ready;
   reg              v_ready;
   output           v_fetched;
   reg              v_fetched;
   output           v_done;
   reg              v_done;
   
   parameter [4:0]  statetype_wfi = 0,
                    statetype_decode_wait = 1,
                    statetype_vmovrv = 2,
                    statetype_vmovrrn = 3,
                    statetype_vmovrnv = 4,
                    statetype_valu1 = 5,
                    statetype_valu2 = 6,
                    statetype_valu3 = 7,
                    statetype_vld = 8,
                    statetype_vtos = 9,
                    statetype_movrts = 10,
                    statetype_mova = 11,
                    statetype_shuffle1 = 12,
                    statetype_shuffle2 = 13,
                    statetype_shuffle3 = 14,
                    statetype_vmol = 15,
                    statetype_vmor = 16;
   
   reg [4:0]        state;
   reg [4:0]        nextstate;
   
   
   always
   begin
      @(posedge clk);
      state <= nextstate;
   end
   
   
   always @(state or ir or ir_ready or s_ready or s_fetched or out_valid or shuffle_valid)
   begin
      load_r <= 1'b0;
      cc9 <= 2'b00;
      c10 <= 1'b0;
      c11 <= 1'b0;
      c12 <= 1'b0;
      cc13 <= 2'b00;
      v_ready <= 1'b0;
      v_fetched <= 1'b0;
      v_done <= 1'b0;
      valu_go <= 1'b0;
      shuffle_go <= 1'b0;
      
      nextstate <= statetype_wfi;
      
      case (state)
         
         statetype_wfi :
            if (ir_ready == 1'b1)
               nextstate <= statetype_decode_wait;
            else
            begin
               v_done <= 1'b1;
               nextstate <= statetype_wfi;
            end
         
         statetype_decode_wait :
            case (ir[19:18])
               2'b00 :
                  if (ir[17] == 1'b0)
                     nextstate <= statetype_wfi;
                  else
                     case (ir[15:12])
                        4'b0001 :
                           nextstate <= statetype_vmovrv;
                        
                        4'b0010 :
                           nextstate <= statetype_vmovrrn;
                        
                        4'b0011 :
                           nextstate <= statetype_vmovrnv;
                        
                        4'b1000 :
                           nextstate <= statetype_vmol;
                        
                        4'b1100 :
                           nextstate <= statetype_vmor;
                        
                        default :
                           nextstate <= statetype_wfi;
                     endcase
               
               2'b01 :
                  nextstate <= statetype_valu1;
               
               2'b10 :
                  case (ir[15:12])
                     4'b0010 :
                        if (s_ready == 1'b1)
                           nextstate <= statetype_vld;
                        else
                           nextstate <= statetype_decode_wait;
                     
                     4'b0011, 4'b0101 :
                        nextstate <= statetype_vtos;
                     
                     4'b0100 :
                        if (s_ready == 1'b1)
                           nextstate <= statetype_movrts;
                        else
                           nextstate <= statetype_decode_wait;
                     
                     4'b0110 :
                        if (s_ready == 1'b1)
                           nextstate <= statetype_mova;
                        else
                           nextstate <= statetype_decode_wait;
                     
                     default :
                        nextstate <= statetype_wfi;
                  endcase
               
               2'b11 :
                  if (use_shuffle)
                     nextstate <= statetype_shuffle1;
                  else
                     nextstate <= statetype_wfi;
               default :
                  nextstate <= statetype_wfi;
            endcase
         
         statetype_vmol :
            begin
               cc13 <= 2'b10;
               cc9 <= 2'b11;
               load_r <= 1'b1;
               nextstate <= statetype_wfi;
            end
         
         statetype_vmor :
            begin
               cc13 <= 2'b11;
               cc9 <= 2'b11;
               load_r <= 1'b1;
               nextstate <= statetype_wfi;
            end
         
         statetype_vmovrv :
            begin
               cc13 <= 2'b01;
               cc9 <= 2'b11;
               load_r <= 1'b1;
               nextstate <= statetype_wfi;
            end
         
         statetype_vmovrrn :
            begin
               cc13 <= 2'b01;
               cc9 <= 2'b11;
               c11 <= 1'b1;
               load_r <= 1'b1;
               nextstate <= statetype_wfi;
            end
         
         statetype_vmovrnv :
            begin
               cc13 <= 2'b01;
               cc9 <= 2'b11;
               c10 <= 1'b1;
               load_r <= 1'b1;
               nextstate <= statetype_wfi;
            end
         
         statetype_valu1 :
            begin
               valu_go <= 1'b1;
               nextstate <= statetype_valu2;
            end
         
         statetype_valu2 :
            if (out_valid == 1'b0)
               nextstate <= statetype_valu2;
            else
               nextstate <= statetype_valu3;
         
         statetype_valu3 :
            begin
               load_r <= 1'b1;
               nextstate <= statetype_wfi;
            end
         
         statetype_vld :
            begin
               cc9 <= 2'b10;
               load_r <= 1'b1;
               v_fetched <= 1'b1;
               nextstate <= statetype_wfi;
            end
         
         statetype_vtos :
            begin
               v_ready <= 1'b1;
               
               if (s_fetched == 1'b1)
                  nextstate <= statetype_wfi;
               else
                  nextstate <= statetype_vtos;
            end
         
         statetype_movrts :
            begin
               cc9 <= 2'b01;
               c12 <= 1'b1;
               load_r <= 1'b1;
               v_fetched <= 1'b1;
               nextstate <= statetype_wfi;
            end
         
         statetype_mova :
            begin
               cc9 <= 2'b01;
               load_r <= 1'b1;
               v_fetched <= 1'b1;
               nextstate <= statetype_wfi;
            end
         
         statetype_shuffle1 :
            begin
               shuffle_go <= 1'b1;
               nextstate <= statetype_shuffle2;
            end
         
         statetype_shuffle2 :
            if (shuffle_valid == 1'b0)
               nextstate <= statetype_shuffle2;
            else
               nextstate <= statetype_shuffle3;
         
         statetype_shuffle3 :
            begin
               cc9 <= 2'b11;
               load_r <= 1'b1;
               nextstate <= statetype_wfi;
            end
      endcase
   end
   
endmodule

